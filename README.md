# 1. Logger
  Проект представляет из себя классический логгер, который будет выводить необходимые пользователю сообщения. Логгер является довольно гибким, так как имеет множество режимов,       которые можно комбинировать:
  ### - в первую очередь пользователь должен понимать, куда он хочет выводить сообщения, поэтому данный логгер обладает тремя режимами вывода, а именно 
  ```Java
    public enum TypeOfOutput {
        FILE,
        CONSOLE,
        BOTH
    }
  ```
  **FILE** - говорит о том, что сообщения выводятся в файл (если такового не существует, то логгер сам создаст его). Также можно указать путь к своему собственному файлу с помощью соответствующего сеттера 
  ```Java
    public void setFileName(String fileName);
  ```
  **CONSOLE** - говорит о том, что сообщения выводятся в консоль.
  
  ![image](https://user-images.githubusercontent.com/49618499/121579805-bd6bc980-ca34-11eb-84a5-b54ea7328ea0.png)
  
  **BOTH** - сообщения выводятся как в консоль, так и в файл.
  
  ### - во вторую очередь пользователю важно, как именно выводятся сообщения - сразу же по сигналу или накопительным образом. Для этого есть два режима:
  ```Java
    public enum Mode {
        ACCUMULATION,
        STRAIGHT
    }
  ```
  **STRAIGHT** - прямое логгирование "as-is", передаем логгеру сообщение и он его выводит.
  
  **ACCUMULATION** - накопительное логгирование, т.е. пользователь передает логгеру некоторое количество сообщений, после чего дает ему сигнал о поочередном выводе этих          сообщений   с сохранением порядка. Данная схема реализована с помощью контейнера для накопления сообщений, а также "сигнального" метода flush().
  ```Java
    private List<String> accumulationList;
    ...
    public void flush();
  ```
  
  ### - характерной особенностью каждого логгера являются, конечно же, уровни логгирования
  ```Java
    public enum Level {
        DEBUG,
        INFO,
        WARNING,
        ERROR,
        FATAL
    }
  ```
  Установить уровень логгера можно сеттером, а уровни сообщений методами
  ```Java
    public void debug(String message);
    public void info(String message);
    public void warning(String message);
    public void error(String message);
    public void fatal(String message);
  ```
  Непосредственно в коде уровни расположены в порядке важности, то есть если уровень логгера, например, ERROR, то сообщение с уровнем DEBUG будет проигнорировано.
  ### - данный логгер также является Singleton: реализовано это с помощью приватного конструктора, что не позволяет создавать более одного экземпляра логгера.
  #### Пример использования:
  Если не устанавливать изначально никакие режимы, то они по умолчанию выставляются так - прямой вывод в консоль с уровнем DEBUG.
  
  ![image](https://user-images.githubusercontent.com/49618499/121583404-df674b00-ca38-11eb-9c7f-70e9a025c4a5.png)
  
  В данном примере мы установили накопительное логгирование с выводом в консоль и режимом WARNING. Сообщения не выведутся, пока не будет вызван метод flush().
  Попробуем теперь залоггировать сообщение в файл 
  
  ![image](https://user-images.githubusercontent.com/49618499/121584168-d9be3500-ca39-11eb-818c-7b9bd715262c.png)

  ![image](https://user-images.githubusercontent.com/49618499/121584256-f5294000-ca39-11eb-8f30-26a467f4b516.png)

  Видим, что сообщения выводятся без вызова метода flush() (т.к. был поставлен режим прямого логгирования), а также, что создался файл log.txt, в котором вывелись все наши        сообщения, соответствуя правилам уровней.
  
  # 2. Dependences management
  
  В данном проекте рассматривается менеджмент зависимостей между двумя проектами, один из которых собран с помощью Gradle.
  SimpleProjectOne собран с помощью Gradle, так же для него создан JAR-артефакт, который мы будем подключать к проекту TestProject, чтобы в нем использовать код первого проекта.
  JAR-артефакт создается с помощью такого блока в файле build.gradle 
  
  ```Java
  jar {
    manifest {
        attributes "Main-Class": "Summator"
    }

    from {
        configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }
    }
  }
  ```
  После чего сам джарник можно найти по пути build/libs/SimpleProjectOne-1.0-SNAPSHOT.jar из репозитории проекта.
  SimpleProjectOne представляет из себя класс, имеющий единственный метод сложения двух целых чисел, которые потом проверяются парой тестов.
  Создадим второй проект TestProject, собранный с помощью Maven - проект этот пустой и мы будем в нем проверять только код из первого проекта.
  
  Как же нам подключить Gradle-проект? 
  ### - для начала установим джарник в локальный репозиторий Maven в проекте TestProject с помощью команды 
  
  ```Java
  mvn install:install-file 
  -Dfile=C:\Users\HP\Desktop\SimpleProjectOne\build\libs\SimpleProjectOne-1.0-SNAPSHOT.jar 
  -DgroupId=test.class 
  -DartifactId=test-class 
  -Dversion=1.0 
  -Dpackaging=jar 
  -DgeneratePom=true 
  ```
  ![image](https://user-images.githubusercontent.com/49618499/121589087-56074700-ca3f-11eb-82c1-b3ce674fe3fa.png)

  ### - после выполнения команды осталось только подключить необходимую зависимость в Maven
  
  ![image](https://user-images.githubusercontent.com/49618499/121589244-85b64f00-ca3f-11eb-9630-b33f8ed18b63.png)
  
  Все! Теперь в проекте TestProject мы можем использовать код из проекта SimpleProjectOne!
  
  Проверим это
  
  ![image](https://user-images.githubusercontent.com/49618499/121589468-c3b37300-ca3f-11eb-9c54-59f60a90b66a.png)
  
  Все отлично работает!

  # 3. XML parser
  Последний проект представляет из себя XML парсер. На вход ему подается XML-файл, а на выходе мы получаем готовый класс с заполненными полями. 
  Структура парсера такова: Имеется парсер-оболочка для нашего конкретного XML-файла (телефонной книги), а внутри у него в качестве поля находится общий парсер, который работает уже с любым XML-файлом, преобразовывая его в документ, откуда с легкостью можно извлекать нужные поля. 
  
  Наш XML-файл выглядит так
  
  ![image](https://user-images.githubusercontent.com/49618499/121706482-56a2ea80-cade-11eb-8940-83ef75ac7d15.png)
  
  Как видно, телефонная книга содержит в себе информацию о людях, у которых есть имя, емейл и свои собственные несколько номеров.
  Рассмотрим теперь устройство самого парсера:
  ### - общий парсер работает очень просто на базе библиотеки DOM
  Он содержит в себе методы непосредственно парсинга и выдачи массива с нашими полями
  
  ```Java
    public static boolean parse(String path);
    ...
    public static NodeList getNodeList();
  ```
  
  В библиотеке DOM файл преобразуется в древовидную структуру NodeMap с узлами Node - действительно, любой XML имеет древовидную структуру.
  Непосредственно в нашем парсере телефонной книги мы вовсю пользуемся методами этой библиотеки - извлекаем поля по имени тега.

  Рассмотрим работу парсера через дебаггер:
  
  ![image](https://user-images.githubusercontent.com/49618499/121708037-d5e4ee00-cadf-11eb-8d6f-7555bf73094c.png)
  
  Как видим, содержимое класса phoneBook полностью соответствует содержанию XML-файла. Все поля телефонной книги заполнены полями Person, которые в свою очередь также создаются внутри парсера телефонной книги и заполняются уже полями более простого типа.
